<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>cm-chessboard</title>
    <meta name="viewport" content="width=device-width, user-scalable=yes, initial-scale=1.0"/>
    <link rel="stylesheet" href="./assets/chessboard.css"/>
    <link rel="stylesheet" href="./assets/extensions/markers/markers.css"/>
    <link rel="stylesheet" href="./assets/extensions/promotion-dialog/promotion-dialog.css"/>
</head>
<body>
<div class="board" id="board" style="width: 600px; max-width: min(95vh, 95vw);"></div>
<div id="output"></div>

<script type="module">
import {INPUT_EVENT_TYPE, COLOR, Chessboard, BORDER_TYPE} from "./src/Chessboard.js"
import {MARKER_TYPE, Markers} from "./src/extensions/markers/Markers.js"
import {PROMOTION_DIALOG_RESULT_TYPE, PromotionDialog} from "./src/extensions/promotion-dialog/PromotionDialog.js"
import {Accessibility} from "./src/extensions/accessibility/Accessibility.js"
import {Chess} from "./src/chess.js"

(async () => {
    // Instantiate cchess WebAssembly module
    const module = await WebAssembly.instantiateStreaming(fetch("./cchess.wasm"))
    const CChess = module.instance.exports

    const CChessMap = " prnbqk"
    const a = "a".charCodeAt(0)
    const one = "1".charCodeAt(0)

    // Set up cm-chessboard
    const chess = new Chess()
    CChess.reset();

    function encodeMove(move) {
        // Encode a chess.js move for cchess.wasm
        const fromFile = move.from.charCodeAt(0) - a
        const fromRank = move.from.charCodeAt(1) - one
        const toFile = move.to.charCodeAt(0) - a
        const toRank = move.to.charCodeAt(1) - one
        const promotion = move.promotion ? CChessMap.indexOf(move.promotion) : 0

        return promotion | (toFile << 3) | (toRank << 6) | (fromFile << 9) | (fromRank << 12)
    }

    function decodeMove(enc) {
        // Encode a cchess.wasm move for chess.js
        if (enc & (1 << 31)) {
            throw "Error received from CChess!"
        }

        const fromRank = String.fromCharCode(((enc >> 12) & 0x7) + one)
        const fromFile = String.fromCharCode(((enc >> 9) & 0x7) + a)
        const toRank = String.fromCharCode(((enc >> 6) & 0x7) + one)
        const toFile = String.fromCharCode(((enc >> 3) & 0x7) + a)
        const promotion = (enc & 0x7) ? CChessMap.charAt(enc & 0x7) : undefined

        return {
            from: fromFile + fromRank,
            to: toFile + toRank,
            ...(promotion ? { promotion } : {}),
        }
    }

    function makeEngineMove(chessboard, playerMove) {
        const possibleMoves = chess.moves({verbose: true})
        if (possibleMoves.length > 0) {
            // Call into cchess.wasm for the next move
            if (!CChess.move(encodeMove(playerMove))) throw "Failed to apply player move!"
            const enc = CChess.get_move()
            const nextMove = decodeMove(enc)
            if (!CChess.move(enc)) throw "Failed to apply AI move!"

            setTimeout(() => { // smoother with 500ms delay
                chess.move(nextMove)
                chessboard.setPosition(chess.fen(), true)
                chessboard.enableMoveInput(inputHandler, COLOR.white)
            }, 500)
        }
    }

    function inputHandler(event) {
        console.log("inputHandler", event)
        if(event.type === INPUT_EVENT_TYPE.movingOverSquare) {
            return // ignore this event
        }
        if(event.type !== INPUT_EVENT_TYPE.moveInputFinished) {
            event.chessboard.removeLegalMovesMarkers()
        }
        if (event.type === INPUT_EVENT_TYPE.moveInputStarted) {
            // mark legal moves
            const moves = chess.moves({square: event.squareFrom, verbose: true})
            event.chessboard.addLegalMovesMarkers(moves)
            return moves.length > 0
        } else if (event.type === INPUT_EVENT_TYPE.validateMoveInput) {
            const move = {from: event.squareFrom, to: event.squareTo, promotion: event.promotion}
            const result = chess.move(move)
            if (result) {
                event.chessboard.state.moveInputProcess.then(() => { // wait for the move input process has finished
                    event.chessboard.setPosition(chess.fen(), true).then(() => { // update position, maybe castled and wait for animation has finished
                        makeEngineMove(event.chessboard, move)
                    })
                })
            } else {
                // promotion?
                let possibleMoves = chess.moves({square: event.squareFrom, verbose: true})
                for (const possibleMove of possibleMoves) {
                    if (possibleMove.promotion && possibleMove.to === event.squareTo) {
                        event.chessboard.showPromotionDialog(event.squareTo, COLOR.white, (result) => {
                            console.log("promotion result", result)
                            if (result.type === PROMOTION_DIALOG_RESULT_TYPE.pieceSelected) {
                                const move = {from: event.squareFrom, to: event.squareTo, promotion: result.piece.charAt(1)}
                                chess.move(move)
                                event.chessboard.setPosition(chess.fen(), true)
                                makeEngineMove(event.chessboard, move)
                            } else {
                                // promotion canceled
                                event.chessboard.enableMoveInput(inputHandler, COLOR.white)
                                event.chessboard.setPosition(chess.fen(), true)
                            }
                        })
                        return true
                    }
                }
            }
            return result
        } else if (event.type === INPUT_EVENT_TYPE.moveInputFinished) {
            if(event.legalMove) {
                event.chessboard.disableMoveInput()
            }
        }
    }

    const board = new Chessboard(document.getElementById("board"), {
        position: chess.fen(),
        assetsUrl: "./assets/",
        style: {borderType: BORDER_TYPE.none, pieces: {file: "pieces/standard.svg"}, animationDuration: 300},
        orientation: COLOR.white,
        extensions: [
            {class: Markers, props: {autoMarkers: MARKER_TYPE.square}},
            {class: PromotionDialog},
            {class: Accessibility, props: {visuallyHidden: true}}
        ]
    })
    board.enableMoveInput(inputHandler, COLOR.white)

})();
</script>
</body>
</html>
